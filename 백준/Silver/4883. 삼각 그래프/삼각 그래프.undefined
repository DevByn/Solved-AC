#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * 백준 4883 - 삼각 그래프 (DP)
 * 각 정점에 도달하는 최소 비용을 계산하며 내려가는 방식입니다.
 */

const long long INF = 1e15; // 충분히 큰 값 설정

void solve() {
    int N, tc = 1;

    while (cin >> N && N != 0) {
        // 비용을 저장할 2차원 벡터 (N x 3)
        vector<vector<long long>> dp(N, vector<long long>(3));

        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < 3; ++j) {
                cin >> dp[i][j];
            }
        }

        // 1. 첫 번째 행 초기화
        // 시작점은 (0, 1)이므로 (0, 0)으로는 올 수 없습니다.
        dp[0][0] = INF; 
        // dp[0][1]은 그대로 (시작점)
        // dp[0][2]는 시작점에서 오른쪽으로 오는 경우만 가능
        dp[0][2] += dp[0][1];

        // 2. 두 번째 행부터 DP 수행
        for (int i = 1; i < N; ++i) {
            // i행 0열: 위(i-1, 0), 오른쪽 위(i-1, 1)에서 올 수 있음
            dp[i][0] += min(dp[i - 1][0], dp[i - 1][1]);

            // i행 1열: 왼쪽(i, 0), 왼쪽 위(i-1, 0), 위(i-1, 1), 오른쪽 위(i-1, 2)에서 올 수 있음
            dp[i][1] += min({dp[i][0], dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]});

            // i행 2열: 왼쪽(i, 1), 위(i-1, 1), 오른쪽 위(i-1, 2)에서 올 수 있음
            dp[i][2] += min({dp[i][1], dp[i - 1][1], dp[i - 1][2]});
        }

        // 결과 출력: 마지막 행의 가운데 정점의 최소 비용
        cout << tc++ << ". " << dp[N - 1][1] << "\n";
    }
}

int main() {
    // 입출력 속도 향상
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solve();

    return 0;
}